\subsection{Beskrivelse av kode for numerisk løsning}
\subsubsection{Pakker, variabler og parametere}
I dette delkapittelet skal vi se på en numerisk tilnærming til bølgeligningen, koden for simuleringen kan hentes fra 
følgende kilde: \parencite{bølgeSimulering}. 

Først importeres nødvendige pakker for å kunne utføre numeriske beregninger og plotte grafiske fremstillinger. Her
tar vi i bruk numpy for numeriske operasjoner, matplotlib.pyplot for plotting, og matplotlib.animation for å lage 
animasjoner slik som forklart i forrige seksjon. Deretter setter vi konfigurajsonsparametere som definerer
fysiske egenskaper til strengen, samt parametere for den numeriske løsningen. Dette inkluderer lengden $L$ på strengen,
bølgehastigheten $c$ og tiden $s$ vi ønsker å simulere. Videre defineres antall punkter $N$ som skal brukes til å dele 
opp strengen. Dette påvirker nøyaktigheten til den numeriske løsningen, der flere punkter gir en mer nøyaktig løsning,
men øker beregningstid og ressursbruk. Videre definerer vi modi for funksjonen, som er antall bølgetopper som skal være 
tilstede for å lage startformen, hvor en høyere verdi gir skarpere kanter og høyere detaljnivå. 

Videre setter vi opp betingelser for den grafiske fremstillingen, slik som FPS (frames per second) for animasjonen, og
tykkelsen for linjen på grafen. For å sette startformen på grafen setter vi 

\begin{lstlisting}
  initial_shape_type = "pluck"
  pluck_width: float = 0.15
\end{lstlisting}

hvor \verb|"pluck"| indikerer at grafen (i dette tilfellet en streng) skal strekkes, og \verb|pluck_width| definerer hvor bredt området som strekkes er.

\subsubsection{Initialbetingelser funksjonen}
Hensikten med denne funksjonen er å definere startformen til strengen ved $t=0$, som vil si at funksjonen returnerer $u(x,0)$.
Funksjonen tar inn en parameter \verb|x|, som er en numpy array med posisjoner langs strengen. Avhengig av verdien til
\verb|initial_shape_type|, vil funksjonen returnere forskjellige startformer. I dette tilfellet er det \verb|"pluck"| 
som er implementert som vil gi funksjonen en trekant-/teltformet startform, hvor plukkposisjonen bestemmes av følgende 
kode:

\begin{lstlisting}
  if initial_shape_type == "pluck":
    center = pluck_position * length_m
    width = pluck_width * length_m
    return np.clip(1.0 - np.abs(x - center) / width, 0.0, 1.0)
\end{lstlisting}

hvis du setter inn for verdi i vi har satt i starten av koden, vil dette si at strengen blir plukket slik som 
illustrert i figuren nedenfor:

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
        width=0.9\textwidth,
        height=0.5\textwidth,
        axis lines=left,
        xlabel={$x$ [m]},
        ylabel={$u(x,0)$ [m]},
        xmin=0, xmax=1.02,
        ymin=-1.1, ymax=1.1,
        xtick={0.15, 0.45, 1},
        ytick={-1, 0, 1}
        ]
        
        \draw (0,0) -- (0.15,0);
        \draw [dashed] (0.15,0) -- (0.3,1) -- (0.45,0);
        \draw (0.45,0) -- (1,0);
        \fill (0.3,1) circle (2pt);

        \end{axis}
    \end{tikzpicture}
    \caption{Startform av strengen ved $t=0$ når den blir plukket ved $x=0.3$ m.}
\end{figure}

her ser vi at strenger blir plukket i en trekantformet bølge med høyde $y=1.0m$, og bredde på $0.15$ m. Dette er
ikke nøyaktig slik en streng ville sett ut hvis den ble plukket, men det gir en god tilnærming som er enkel å 
implementere i en numerisk modell.

Videre i koden setter vi startfarten til strengen ved $t=0$, som i dette tilfellet er null over hele strengen. Funksjonen som returneres vil 
derfor se slik ut: $g(x)=u_t(x,0)$ og vil returneres for alle verdier av $x$ som er gitt som input til funksjonen. Siden starthastigheten er satt
til $0$, vil \verb|return np.zeros_like(x)| returnere en array med samme form som \verb|x|, men med alle verdier satt til null.

\subsubsection{Oppsett av romlige og tidsmessige akser}
Først linje i denne kodebiten (\verb|np.ndarray x|)setter opp et array av jevnt fordelte punkter mellom $0$ og lengden $L$. Disse punktene vil da representere
posisjonene langs strengen hvor vi beregner $u(x,t)$. Eksempelvis hvis \verb|num_points=5| og \verb|length_m=1.0|, vil arrayet til \verb|x| se slik ut: \verb|x = [0, 0.25, 0.5, 0.75, 1.0]|.
Videre definerer vi \verb|float dt|, for å bergne avstand til naboer. Denne delen av koden er ikke i bruk, men lagt inn for fremtidsformål. Neste 
linje i koden (\verb|float dt|) definerer tidssteg til et bilde per sekund i animasjonen, hvor for \verb|fps=60| vil evaluere tilstanden hvert
$\frac{1}{60} \approx 16.7$ millisekund. Videre er beregning av antall tidssteg (\verb|num_steps = int(duration_s * fps) + 1|). Her vil varigheten
av simulasjonen og antall \verb|fps| bestemme hvor mange tidssteg som er i animasjonen slik at simuleringen var like lenge som animasjonen. Til
slutt har vi tiden \verb|np.ndarray t| som blir et array over alle tider hvor strengen skal beregnes.

\subsubsection{Metodefunksjonen}
I denne funksjonen settes simuleringen i gang. Grafen begynner å bevege seg som følge av de initialbetingelsene som ble definert tidligere. 
Bevegelsen oppstår gjennom stegvise beregninger av strengens utslag over tid. I denne funksjonen settes de ulike komponentene i ligningen
under:

\begin{equation*}
  u(x,t) = \sum_{n=1}^{N} 
  \big[ B_n \cos(\omega_n t) + B_n^{*} \sin(\omega_n t) \big]
  \sin\!\left(\frac{n\pi x}{L}\right)
\end{equation*}


\subsubsection{Animasjonsfunksjonen}
\dots
